{
  "name": "recur-fs",
  "description": "A collection of recursive filesystem utilities",
  "version": "2.2.2",
  "author": "popeindustries <alex@pope-industries.com>",
  "keywords": [
    "fs",
    "recursive",
    "readdir",
    "cp",
    "cp-r",
    "mv",
    "mkdir",
    "mkdir-p",
    "mv",
    "rm",
    "rm-rf",
    "walk"
  ],
  "dependencies": {
    "minimatch": "3.0.2",
    "mkdirp": "0.5.1",
    "rimraf": "2.5.2"
  },
  "devDependencies": {
    "expect.js": "*",
    "mocha": "*"
  },
  "main": "index.js",
  "scripts": {
    "test": "mocha --reporter spec"
  },
  "engines": {
    "node": ">=0.10.0"
  },
  "repository": "git://github.com/popeindustries/recur-fs.git",
  "readmeFilename": "README.md",
  "readme": "[![NPM Version](https://img.shields.io/npm/v/recur-fs.svg?style=flat)](https://npmjs.org/package/recur-fs)\n[![Build Status](https://img.shields.io/travis/popeindustries/recur-fs.svg?style=flat)](https://travis-ci.org/popeindustries/recur-fs)\n\nA collection of recursive filesystem utilities.\n\n## Installation\n\n```bash\nnpm install recur-fs\n```\n\n## Usage\n```javascript\nvar fs = require('recur-fs');\n\n// Gather all nested files and directories\nfs.readdir('/some/directory', function(err, resources) {\n  // Do something with 'resources'\n});\n```\n\n## API\n\n**readdir(directory, visitor(_resource, stat, next_), fn(_err, resources_))** Recursively read contents of `directory`, returning all resources. `visitor` is an optional function called on each resource. Calling `next(false)` from `visitor` will exclude resource from the collection.\n\n```js\nfs.readdir('/some/directory', function (err, resources) {\n  // Do something with 'resources'\n});\n\nfs.readdir('/some/other/directory', function (resource, stat, next) {\n  // Return 'false' to skip adding to 'resources'\n  next(stat.isFile());\n}, function(err, resources) {\n  // Do something with 'resources'\n});\n```\n\n**readdir.sync(directory, visitor(_resource, stat_))** Synchronously, recursively read contents of `directory`, returning all resources. `visitor` is an optional function called on each resource. Returning `false` from `visitor` will exclude resource from the collection.\n\n```js\nvar resources = fs.readdir.sync('/some/directory');\n\nvar files = fs.readdir.sync('/some/other/directory', function (resource, stat) {\n  // Return 'false' to skip adding to 'resources'\n  return stat.isFile();\n});\n```\n\n**walk(directory, visitor(_resource, stat, next_), fn(_err_))** Walk up filesystem tree from `directory`, passing all resources to `visitor`, and stopping when root directory is reached. Calling `next(true)` will abort walking before completion.\n\n```js\nfs.walk('/some/directory', function (resource, stat, next) {\n  // Return 'true' to stop walking\n  next(resource == 'index.js');\n}, function (err) {\n  // Handle error\n});\n```\n\n**walk.sync(directory, visitor(_resource, stat_))** Synchronously walk up filesystem tree from `directory`, passing all resources to `visitor`, and stopping when root directory is reached, or visitor returns `true`.\n\n```js\nfs.walk.sync('/some/directory', function (resource, stat) {\n  // Do something with resource\n});\n```\n\n**hunt(directory, matcher(_resource, stat, next_), stopOnFirstMatch, fn(_err, matches_))** Walk up filesystem tree from `directory`, returning all resources matched with `matcher`, and stopping when root directory is reached, or after first match if `stopOnFirstMatch=true`.\n\n`matcher` can be a glob-type string (see [minimatch](https://github.com/isaacs/minimatch)), or function calling `next(true)` to signal a match. In addition, `next` also accepts a second argument in order to abort before completion.\n\n```js\nfs.hunt('/some/directory', '*.js', false, function (err, matches) {\n  // Do something with matching js files\n});\n\nfs.hunt('/some/directory', '*.css', true, function (err, match) {\n  // Do something with single matching css file\n});\n\nfs.hunt('/some/other/directory', function (resource, stat, next) {\n  if (resource == 'index.js') {\n    // Return second argument to stop walking\n    next(true, true);\n  } else {\n    next(false);\n  }\n}, false, function (err, matches) {\n  // Do something with matches\n});\n```\n\n**hunt.sync(directory, matcher(_resource, stat_), stopOnFirstMatch)** Synchronously walk up filesystem tree from `directory`, returning all resources matched with `matcher`, and stopping when root directory is reached, or after first match if `stopOnFirstMatch=true`.\n\n`matcher` can be a glob-type string (see [minimatch](https://github.com/isaacs/minimatch)), or function returning `true` to signal a match.\n\n```js\nvar jsFiles = fs.hunt.sync('/some/directory', '*.js', false);\n\nvar cssFile = fs.hunt.sync('/some/directory', '*.css', true);\n\nvar index = fs.hunt.sync('/some/other/directory', function (resource, stat) {\n  return (resource == 'index.js');\n}, true);\n```\n\n**cp(source, destination, force, fn(_err, filepath_))** Recursively copy `source` to `destination` (`cp -r`). Copies contents of `source` directory if path contains a trailing `/`. `force=true` will overwrite `destination` if it already exists.\n\n```js\nfs.cp('/some/file', '/some/destination', true, function(err, filepath) {\n  // Do something with new 'filepath'\n});\n\n// Copy directory contents (note trailing slash)\nfs.cp('/some/directory/contents/', '/some/destination', true, function(err, filepath) {\n  // Do something with new 'filepath'\n});\n```\n**cp.sync(source, destination, force)** Synchronously, recursively copy `source` to `destination` (`cp -r`). Copies contents of `source` directory if path contains a trailing `/`. `force=true` will overwrite `destination` if it already exists.\n\n```js\nvar filepath = fs.cp('/some/file', '/some/destination', true);\n```\n\n**mkdir(directory, fn(_err_))** Recursively create nested `directory` (`mkdir -p`). If `directory` looks like a filepath (has .extension), directories will be created at `path.dirname(directory)`.\n\n```js\nfs.mkdir('/some/directory', function(err) {\n  // Do something\n});\n```\n\n**mkdir.sync(directory)** Synchronously, recursively create nested `directory` (`mkdir -p`). If `directory` looks like a filepath (has .extension), directories will be created at `path.dirname(directory)`.\n\n```js\nfs.mkdir.sync('/some/directory');\n```\n\n**mv(source, destination, force, fn(_err, filepath_))** Move `source` to `destination`, including all contents of `source` if directory. `force=true` will overwrite `destination` if it already exists.\n\n```js\nfs.mv('/some/file', '/some/destination', function(err, filepath) {\n  // Do something with new 'filepath'\n});\n```\n\n**mv.sync(source, destination, force)** Synchronously move `source` to `destination`, including all contents of `source` if directory. `force=true` will overwrite `destination` if it already exists.\n\n```js\nfs.mv.sync('/some/file', '/some/destination');\n```\n\n**rm(source, fn(_err_))** Recursively remove `source` (`rm -rf`). Prevents removal of resources outside of `process.cwd()`.\n\n```js\nfs.rm('/some/directory/and/children', function(err) {\n  // Do something when complete\n});\n```\n\n**rm.sync(source)** Synchronously, recursively remove `source` (`rm -rf`). Prevents removal of resources outside of `process.cwd()`.\n\n```js\nfs.rm.sync('/some/directory/and/children');\n```\n\n**indir(directory, filepath)** Check that `filepath` is likely child of `directory`. **NOTE**: only makes string comparison.\n\n```js\nfs.indir('/some/directory', '/some/directory/file');\n```\n",
  "license": "MIT"
}
